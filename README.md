# proxy

## 템플릿 메서드 패턴

- 핵심로직과 부가로직을 분리하여 모듈화하는 디자인 패턴
- 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 사용하여 문제 해결

## 전략 패턴

- 변하지 않는 부분을 **Context**에 두고, 변하는 부분을 **Strategy**라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결. ⇒ 상속이 아니라 **위임**으로 문제를 해결
- 전략패턴에서
    - **Context :** 변하지 않는 템플릿
    - **Strategy :** 변하는 알고리즘
- 핵심! : Context 는 Strategy의 인터페이스에만 의존한다! ⇒ 바로 스프링의 의존관계 주입에서 사용하는 방식
- Context와 Strategy를 단점 조립한 이후에는 전략을 변경하기 번거롭다

## 템플릿 콜백 패턴

- 콜백 : 다른 코드의 인수로서 넘겨주는 실행 가능한 코드

## 프록시 패턴

- 프록시 : 대리자
- 객체에서 프록시가 되려면, 서버와 프록시는 같은 인터페이스를 사용해야 한다.
- 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.
- 런타임 객체 의존관계
    - 프록시 도입 전 : client → server
    - 프록시 도입 후 : client → proxy → server
- **프록시의 주요 기능**
    - 접근 제어 : **권한에 따른 접근 차단**, 캐싱, 지연 로딩
    - 부가 기능 추가 : 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
    <br> 예) 요청 값이나, 응답 값을 중간에 변형한다.
    <br> 예) 실행 시간을 측정해서 추가 로그를 남긴다.
    
## 데코레이터 패턴

- 프록시로 **부가 기능을 추가**하는 것
- 데코레이터 패턴: 원래 서버가 제공하는 기능에 더해서 **부가 기능을 수행**한다. 
<br> 예) 요청 값이나, 응답 값을 중간에 변형한다.
<br> 예) 실행 시간을 측정해서 추가 로그를 남긴다.  

# 스프링이 지원하는 프록시 패턴

### 이전

- 인터페이스가 있는 경우 ⇒ JDK 동적 프록시 적용 (InvocationHandler)
- 인터페이스가 없는 경우 ⇒ cglib 적용 (MethodInterceptor)

### 스프링 제공

- 두가지 상황을 통합한 프록시 팩토리 기능을 제공!
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시 적용하고 없으면 cglib 적용하며, 이 설정을 변경할 수 있다.
- 개발자는 InvocationHandler 나 MethodInterceptor를 사용하지 않고 **Advice**를 사용한다(스프링 제공)
    - MethodInterceptor 사용(cglib 가 사용하는 것과는 다름)
    - MethodInterceptor는 Interceptor를 상속하고 Interceptor는 **Advice**를 상속한다

### 포인트 컷

- 어디에 부가기능을 적용할지 적용하지 말지 판단하는 필터링 로직
- 주로 클래스(`ClassFilter`) & 메서드(`MethodMatcher`) 명으로 필터링한다
- 어딴 ‘포인트’에 기능을 적용할지 잘라서(cut) 구분하는 것
- 스프링 제공 포인트컷
    - `NameMatchMethodPointcut` : 메서드 이름을 기반으로 매칭. 내부에서는 `PatternMatchUtils`  를 사용한다. ex) *xxx* 허용
    - `Pointcut.TRUE`  : 항상 true 를 반환하는 포인트 컷
    - `JdkRegexpMethodPointcut` : jdk 정규 표현식을 기반으로 포인트컷을 매칭
    - `AnnotationPointcut` : 애노테이션으로 매칭
    - `**AspectJExpressionPointcut**` : aspectJ 표현식으로 매칭. 사용하기 편리하고 기능이 가장 많기 때문에 실무에서 가장 많이 사용.

### 어드바이스

- 프록시가 호출하는 부가기능 로직 (프록시 로직)

### 어드바이저

- 포인트컷 1 + 어드바이스 1
- `new DefaultPointcutAdvisor`  Advisor 인터페이스의 가장 일반적인 구현체
    
    

### 중요

- 스프링은 AOP를 적용할때 최적화를 진행하여 프록시를 하나만 만들고, 하나의 프록시에서 여러 어드바이저를 적용한다.
- 하나의 target에 여러 AOP가 동시에 적용되어도, 스프링 AOPSMS target 마다 하나의 프록시만 생성한다.
