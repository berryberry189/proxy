# proxy

## 템플릿 메서드 패턴

- 핵심로직과 부가로직을 분리하여 모듈화하는 디자인 패턴
- 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 사용하여 문제 해결

## 전략 패턴

- 변하지 않는 부분을 **Context**에 두고, 변하는 부분을 **Strategy**라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결. ⇒ 상속이 아니라 **위임**으로 문제를 해결
- 전략패턴에서
    - **Context :** 변하지 않는 템플릿
    - **Strategy :** 변하는 알고리즘
- 핵심! : Context 는 Strategy의 인터페이스에만 의존한다! ⇒ 바로 스프링의 의존관계 주입에서 사용하는 방식
- Context와 Strategy를 단점 조립한 이후에는 전략을 변경하기 번거롭다

## 템플릿 콜백 패턴

- 콜백 : 다른 코드의 인수로서 넘겨주는 실행 가능한 코드

## 프록시 패턴

- 프록시 : 대리자
- 객체에서 프록시가 되려면, 서버와 프록시는 같은 인터페이스를 사용해야 한다.
- 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.
- 런타임 객체 의존관계
    - 프록시 도입 전 : client → server
    - 프록시 도입 후 : client → proxy → server
- **프록시의 주요 기능**
    - 접근 제어 : **권한에 따른 접근 차단**, 캐싱, 지연 로딩
    - 부가 기능 추가 : 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
    <br> 예) 요청 값이나, 응답 값을 중간에 변형한다.
    <br> 예) 실행 시간을 측정해서 추가 로그를 남긴다.
    
## 데코레이터 패턴

- 프록시로 **부가 기능을 추가**하는 것
- 데코레이터 패턴: 원래 서버가 제공하는 기능에 더해서 **부가 기능을 수행**한다. 
<br> 예) 요청 값이나, 응답 값을 중간에 변형한다.
<br> 예) 실행 시간을 측정해서 추가 로그를 남긴다.  

<br><br>
# 스프링이 지원하는 프록시 패턴

### 이전

- 인터페이스가 있는 경우 ⇒ JDK 동적 프록시 적용 (InvocationHandler)
- 인터페이스가 없는 경우 ⇒ cglib 적용 (MethodInterceptor)

### 스프링 제공

- 두가지 상황을 통합한 프록시 팩토리 기능을 제공!
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시 적용하고 없으면 cglib 적용하며, 이 설정을 변경할 수 있다.
- 개발자는 InvocationHandler 나 MethodInterceptor를 사용하지 않고 **Advice**를 사용한다(스프링 제공)
    - MethodInterceptor 사용(cglib 가 사용하는 것과는 다름)
    - MethodInterceptor는 Interceptor를 상속하고 Interceptor는 **Advice**를 상속한다

### 포인트 컷

- 어디에 부가기능을 적용할지 적용하지 말지 판단하는 필터링 로직
- 주로 클래스(`ClassFilter`) & 메서드(`MethodMatcher`) 명으로 필터링한다
- 어딴 ‘포인트’에 기능을 적용할지 잘라서(cut) 구분하는 것
- 스프링 제공 포인트컷
    - `NameMatchMethodPointcut` : 메서드 이름을 기반으로 매칭. 내부에서는 `PatternMatchUtils`  를 사용한다. ex) *xxx* 허용
    - `Pointcut.TRUE`  : 항상 true 를 반환하는 포인트 컷
    - `JdkRegexpMethodPointcut` : jdk 정규 표현식을 기반으로 포인트컷을 매칭
    - `AnnotationPointcut` : 애노테이션으로 매칭
    - `**AspectJExpressionPointcut**` : aspectJ 표현식으로 매칭. 사용하기 편리하고 기능이 가장 많기 때문에 실무에서 가장 많이 사용.

### 어드바이스

- 프록시가 호출하는 부가기능 로직 (프록시 로직)

### 어드바이저

- 포인트컷 1 + 어드바이스 1
- `new DefaultPointcutAdvisor`  Advisor 인터페이스의 가장 일반적인 구현체
    
    
### 중요

- 스프링은 AOP를 적용할때 최적화를 진행하여 프록시를 하나만 만들고, 하나의 프록시에서 여러 어드바이저를 적용한다.
- 하나의 target에 여러 AOP가 동시에 적용되어도, 스프링 AOPSMS target 마다 하나의 프록시만 생성한다.

<br><br>
# 빈 후 처리기 (BeanPostProcessor)

- 스프링 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶은 경우에 사용
- 빈을 생성한 후에 무언가를 처리하는 용도
- 객체를 조작할 수도 있도 완전히 다른 객체로 바꿔치기 하는 것도 가능하다
- 빈 등록 과정 (+ 후 처리기)
    1. 생성 : 스프링 빈 대상이 되는 객체를 생성 (@Bean, 컴포넌트 스캔 등)
    2. 전달 : 생성된 객체를 저장소에 등록하기 직전에 빈 후처리기에 전달
    3. 후 처리 작업 : 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바꿔치기 가능
    4. 등록 : 빈 후처리기는 빈을 반환. 전달된 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기하면 다른 객체가 빈 저장소에 등록된다.
- 빈 후처리기를 사용하면 **빈 실제 객체를 프록시로 교체하는 것도 가능**
    - 수동으로 등록하는 빈 뿐만 아리라 컴포넌트 스캔을 사용하는 빈까지 프록시를 적용할 수 있으며 설정 파일에 있는 수많은 프록시 생성 코드도 한번에 제거할 수 있다

### 인터페이스 `BeanPostProcessor`

- `postProcessBeforeInitialization`
    - 객체 생성 이후에 @PostConstruct 같은 초기화가 발생하기 전에 호출되는 포스트 프로세서
- `postProcessAfterInitialization`
    - 객체 생성 이후에 @PostConstruct 같은 초기화가 발생한 다음에 호출되는 포스트 프로세서

### AutoProxyCreator 자동프록시 생성기

- `implementation 'org.springframework.boot:spring-boot-starter-aop'` 추가 시 `AnnotationAwareAspectJAutoProxyCreator` 라는 빈 후처리기가 스프링빈에 자동으로 등록됨
- 자동으로 프록시를 생성해주는 빈 후처리기
- 스프링 빈으로 등록된 Advisor 들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용해줌. → Advisor (Pointcut + Advice) 이므로 Advisor만 알고있으면 그 안에있는 Pointcut으로 어떤 프록시를 적용해야 할지 알 수 있다.
    - 포인트컷이 사용되는 2가지 경우
        1. 프록시 적용 여부 판단 - 생성단계
            1. 포인트컷을 사용해서 해당 빈이 프록시를 생성할 필요가 있는지 클래스 + 매서드를 모두 비교한다
        2. 어드바이스 적용 여부 판단 - 사용단계
            1. 프록시가 호출되었을 때 부가기능인 어드바이스를 적용할지말지 포인트컷을 보고 판단한다
- @AspectJ와 관련된 AOP 기능도 자동으로 찾아서 처리해준다

### 하나의 프록시 여러 어드바이저

- 어떤 스프링 빈이 advisor1, advisor2 가 제공하는 포인트컷의 조건을 모두 만족 ⇒  프록시 여러개가 아닌 프록사는 한개만 생성하며 하나의 프록시에 여러 어드바이저를 포함한다.
- 상황별 정리
    - advisor1 의 포인트컷만 만족 프록시1개 생성, 프록시에 advisor1 만 포함
    - advisor1 , advisor2 의 포인트컷을 모두 만족 프록시1개 생성, 프록시에 advisor1 , advisor2 모두 포함
    - advisor1 , advisor2 의 포인트컷을 모두 만족하지 않음 프록시가 생성되지 않음
 
<br><br>
# @Aspect AOP

### **@Aspect 프록시**

- 자동 프록시 생성기 ( AnnotationAwareAspectJAutoProxyCreator )는 Advisor 를 자동으로 찾아와서 필요한 곳에 프록시를 생성하고 적용해준다
- 자동 프록시 생성기는 여기에 추가로 하나의 역할을 더 하는데, 바로 @Aspect 를 찾아서 이것을 Advisor 로 만들어준다

### **@Aspect 를 어드바이저로 변환해서 저장하는 과정**
**1. 실행:** 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기를 호출한다.

**2. 모든 @Aspect 빈 조회:** 자동 프록시 생성기는 스프링 컨테이너에서 @Aspect 애노테이션이 붙은 스프링 빈을 모두 조회한다.

**3. 어드바이저 생성:** @Aspect 어드바이저 빌더를 통해 @Aspect 애노테이션 정보를 기반으로 어드바이저를 생성한다.

**4. @Aspect 기반 어드바이저 저장:** 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장한다.

### **어드바이저를 기반으로 프록시 생성**


**1. 생성:** 스프링 빈 대상이 되는 객체를 생성한다. ( @Bean , 컴포넌트 스캔 모두 포함)

**2. 전달:** 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.

**3-1. Advisor 빈 조회:** 스프링 컨테이너에서 Advisor 빈을 모두 조회한다.

**3-2. @Aspect Advisor 조회:** @Aspect 어드바이저 빌더 내부에 저장된 Advisor 를 모두 조회한다.

**4. 프록시 적용 대상 체크:** 앞서 3-1, 3-2에서 조회한 Advisor 에 포함되어 있는 포인트컷을 사용해서
해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의
모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용
대상이 된다. 예를 들어서 메서드 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.

**5. 프록시 생성:** 프록시 적용 대상이면 프록시를 생성하고 프록시를 반환한다. 그래서 프록시를 스프링
빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로
등록한다.

**6. 빈 등록:** 반환된 객체는 스프링 빈으로 등록된다.
