# proxy

## 템플릿 메서드 패턴

- 핵심로직과 부가로직을 분리하여 모듈화하는 디자인 패턴
- 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 사용하여 문제 해결

## 전략 패턴

- 변하지 않는 부분을 **Context**에 두고, 변하는 부분을 **Strategy**라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결. ⇒ 상속이 아니라 **위임**으로 문제를 해결
- 전략패턴에서
    - **Context :** 변하지 않는 템플릿
    - **Strategy :** 변하는 알고리즘
- 핵심! : Context 는 Strategy의 인터페이스에만 의존한다! ⇒ 바로 스프링의 의존관계 주입에서 사용하는 방식
- Context와 Strategy를 단점 조립한 이후에는 전략을 변경하기 번거롭다

## 템플릿 콜백 패턴

- 콜백 : 다른 코드의 인수로서 넘겨주는 실행 가능한 코드

## 프록시 패턴

- 프록시 : 대리자
- 객체에서 프록시가 되려면, 서버와 프록시는 같은 인터페이스를 사용해야 한다.
- 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.
- 런타임 객체 의존관계
    - 프록시 도입 전 : client → server
    - 프록시 도입 후 : client → proxy → server
- **프록시의 주요 기능**
    - 접근 제어 : **권한에 따른 접근 차단**, 캐싱, 지연 로딩
    - 부가 기능 추가 : 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
    <br> 예) 요청 값이나, 응답 값을 중간에 변형한다.
    <br> 예) 실행 시간을 측정해서 추가 로그를 남긴다.
    
## 데코레이터 패턴

- 프록시로 **부가 기능을 추가**하는 것
- 데코레이터 패턴: 원래 서버가 제공하는 기능에 더해서 **부가 기능을 수행**한다. 
<br> 예) 요청 값이나, 응답 값을 중간에 변형한다.
<br> 예) 실행 시간을 측정해서 추가 로그를 남긴다.  
